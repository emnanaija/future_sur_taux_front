{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\n\n// Define form sections with their required fields and validation rules\n\nexport const FORM_SECTIONS = [{\n  id: 'identification',\n  title: \"Identification de l'instrument\",\n  description: \"Informations de base\",\n  fields: ['symbol', 'description', 'isin', 'expirationCode', 'parentTicker', 'fullName', 'segment', 'maturityDate'],\n  requiredFields: ['symbol', 'isin', 'fullName'],\n  validationMessages: {\n    symbol: 'Le symbole est requis pour identifier l\\'instrument',\n    isin: 'Le code ISIN est obligatoire',\n    fullName: 'Le nom complet de l\\'instrument est requis'\n  }\n}, {\n  id: 'deposit',\n  title: \"Dépôt & sous-jacents\",\n  description: \"Configuration des marges\",\n  fields: ['depositType', 'lotSize', 'initialMarginAmount', 'percentageMargin', 'underlyingType', 'underlyingId'],\n  requiredFields: ['depositType', 'lotSize', 'underlyingType', 'underlyingId'],\n  validationMessages: {\n    depositType: 'Veuillez sélectionner le type de dépôt',\n    lotSize: 'La taille de lot doit être supérieure à 0',\n    underlyingType: 'Veuillez sélectionner le type de sous-jacent',\n    underlyingId: 'Veuillez sélectionner un sous-jacent'\n  }\n}, {\n  id: 'trading',\n  title: \"Négociation\",\n  description: \"Paramètres de trading\",\n  fields: ['firstTradingDate', 'lastTraadingDate', 'tradingCurrency', 'tickSize', 'settlementMethod', 'instrumentStatus'],\n  requiredFields: ['firstTradingDate', 'lastTraadingDate', 'tradingCurrency', 'tickSize', 'settlementMethod'],\n  validationMessages: {\n    firstTradingDate: 'La date de première négociation est requise',\n    lastTraadingDate: 'La date de dernière négociation est requise',\n    tradingCurrency: 'La devise de négociation est obligatoire',\n    tickSize: 'Le tick size doit être supérieur à 0',\n    settlementMethod: 'Veuillez sélectionner la méthode de règlement'\n  }\n}];\nexport const useFormNavigation = (form, errors) => {\n  _s();\n  const [currentStep, setCurrentStep] = useState(0);\n  const [completedSteps, setCompletedSteps] = useState(new Set());\n  const [justArrivedOnLastStep, setJustArrivedOnLastStep] = useState(false);\n\n  // Check if a step is completed\n  const isStepCompleted = useCallback(stepIndex => {\n    const section = FORM_SECTIONS[stepIndex];\n    if (!section) return false;\n    return section.requiredFields.every(field => {\n      const value = form[field];\n      if (typeof value === 'string') {\n        return value.trim() !== '';\n      }\n      if (typeof value === 'number') {\n        return value > 0;\n      }\n      if (typeof value === 'boolean') {\n        return true; // Boolean fields are always considered valid\n      }\n      return value !== undefined && value !== null;\n    });\n  }, [form]);\n\n  // Validate current step with detailed feedback\n  const validateCurrentStep = useCallback(() => {\n    const section = FORM_SECTIONS[currentStep];\n    if (!section) {\n      return {\n        isValid: false,\n        missingFields: [],\n        errorMessages: ['Section invalide'],\n        canProceed: false\n      };\n    }\n    const missingFields = [];\n    const errorMessages = [];\n\n    // Check required fields\n    section.requiredFields.forEach(field => {\n      const value = form[field];\n      let isValid = true;\n      if (typeof value === 'string') {\n        isValid = value.trim() !== '';\n      } else if (typeof value === 'number') {\n        isValid = value > 0;\n      } else if (typeof value === 'boolean') {\n        isValid = true;\n      } else {\n        isValid = value !== undefined && value !== null;\n      }\n      if (!isValid) {\n        missingFields.push(field);\n        errorMessages.push(section.validationMessages[field] || `Le champ ${field} est requis`);\n      }\n    });\n\n    // Check for validation errors\n    section.fields.forEach(field => {\n      if (errors[field]) {\n        errorMessages.push(errors[field]);\n      }\n    });\n    const isValid = missingFields.length === 0 && errorMessages.length === 0;\n    const canProceed = isValid;\n    return {\n      isValid,\n      missingFields,\n      errorMessages,\n      canProceed\n    };\n  }, [currentStep, form, errors]);\n\n  // Check if current step has errors\n  const hasStepErrors = useCallback(() => {\n    const section = FORM_SECTIONS[currentStep];\n    if (!section) return false;\n    return section.fields.some(field => errors[field]);\n  }, [currentStep, errors]);\n\n  // Get validation summary for current step\n  const getCurrentStepValidation = useCallback(() => {\n    return validateCurrentStep();\n  }, [validateCurrentStep]);\n\n  // Get validation summary for specific step\n  const getStepValidation = useCallback(stepIndex => {\n    const section = FORM_SECTIONS[stepIndex];\n    if (!section) {\n      return {\n        isValid: false,\n        missingFields: [],\n        errorMessages: ['Section invalide'],\n        canProceed: false\n      };\n    }\n    const missingFields = [];\n    const errorMessages = [];\n    section.requiredFields.forEach(field => {\n      const value = form[field];\n      let isValid = true;\n      if (typeof value === 'string') {\n        isValid = value.trim() !== '';\n      } else if (typeof value === 'number') {\n        isValid = value > 0;\n      } else if (typeof value === 'boolean') {\n        isValid = true;\n      } else {\n        isValid = value !== undefined && value !== null;\n      }\n      if (!isValid) {\n        missingFields.push(field);\n        errorMessages.push(section.validationMessages[field] || `Le champ ${field} est requis`);\n      }\n    });\n    const isValid = missingFields.length === 0;\n    const canProceed = isValid;\n    return {\n      isValid,\n      missingFields,\n      errorMessages,\n      canProceed\n    };\n  }, [form]);\n\n  // Go to next step\n  const nextStep = useCallback(() => {\n    if (currentStep >= FORM_SECTIONS.length - 1) {\n      return false; // Already on last step\n    }\n    const validation = validateCurrentStep();\n    if (!validation.canProceed) {\n      return false; // Current step is not valid\n    }\n\n    // Mark current step as completed\n    setCompletedSteps(prev => new Set(prev).add(currentStep));\n\n    // Move to next step\n    const nextStepIndex = currentStep + 1;\n    setCurrentStep(nextStepIndex);\n\n    // Check if we just arrived on the last step\n    if (nextStepIndex === FORM_SECTIONS.length - 1) {\n      setJustArrivedOnLastStep(true);\n    }\n    return true;\n  }, [currentStep, validateCurrentStep]);\n\n  // Go to previous step\n  const prevStep = useCallback(() => {\n    if (currentStep <= 0) {\n      return false; // Already on first step\n    }\n    setCurrentStep(prev => prev - 1);\n    setJustArrivedOnLastStep(false);\n    return true;\n  }, [currentStep]);\n\n  // Go to specific step\n  const goToStep = useCallback(stepIndex => {\n    if (stepIndex < 0 || stepIndex >= FORM_SECTIONS.length) {\n      return false; // Invalid step index\n    }\n\n    // Only allow going to completed steps or the next available step\n    if (stepIndex > currentStep && !completedSteps.has(stepIndex - 1)) {\n      return false; // Cannot skip steps\n    }\n    setCurrentStep(stepIndex);\n    setJustArrivedOnLastStep(stepIndex === FORM_SECTIONS.length - 1);\n    return true;\n  }, [currentStep, completedSteps]);\n\n  // Check if form is ready for submission\n  const isFormReadyForSubmission = useCallback(() => {\n    // Must be on last step\n    if (currentStep !== FORM_SECTIONS.length - 1) {\n      return false;\n    }\n\n    // All steps must be completed\n    if (completedSteps.size < FORM_SECTIONS.length - 1) {\n      return false;\n    }\n\n    // Current step must be valid\n    return validateCurrentStep().canProceed;\n  }, [currentStep, completedSteps, validateCurrentStep]);\n\n  // Get current section\n  const getCurrentSection = useCallback(() => {\n    return FORM_SECTIONS[currentStep];\n  }, [currentStep]);\n\n  // Get section by index\n  const getSection = useCallback(index => {\n    return FORM_SECTIONS[index];\n  }, []);\n  return {\n    // State\n    currentStep,\n    completedSteps,\n    justArrivedOnLastStep,\n    // Actions\n    nextStep,\n    prevStep,\n    goToStep,\n    // Computed values\n    isStepCompleted,\n    validateCurrentStep,\n    hasStepErrors,\n    isFormReadyForSubmission,\n    getCurrentSection,\n    getSection,\n    getCurrentStepValidation,\n    getStepValidation,\n    // Constants\n    totalSteps: FORM_SECTIONS.length,\n    sections: FORM_SECTIONS\n  };\n};\n_s(useFormNavigation, \"nG3LJYXrLCefNggYL3yMiM++Mr4=\");","map":{"version":3,"names":["useState","useCallback","FORM_SECTIONS","id","title","description","fields","requiredFields","validationMessages","symbol","isin","fullName","depositType","lotSize","underlyingType","underlyingId","firstTradingDate","lastTraadingDate","tradingCurrency","tickSize","settlementMethod","useFormNavigation","form","errors","_s","currentStep","setCurrentStep","completedSteps","setCompletedSteps","Set","justArrivedOnLastStep","setJustArrivedOnLastStep","isStepCompleted","stepIndex","section","every","field","value","trim","undefined","validateCurrentStep","isValid","missingFields","errorMessages","canProceed","forEach","push","length","hasStepErrors","some","getCurrentStepValidation","getStepValidation","nextStep","validation","prev","add","nextStepIndex","prevStep","goToStep","has","isFormReadyForSubmission","size","getCurrentSection","getSection","index","totalSteps","sections"],"sources":["C:/Users/chemseddine/Desktop/frontend/src/components/forms/FutureCreationForm/hooks/useFormNavigation.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { FutureFormData } from '../schemas/futureFormSchema';\r\n\r\n// Define form sections with their required fields and validation rules\r\nexport interface FormSection {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  fields: (keyof FutureFormData)[];\r\n  requiredFields: (keyof FutureFormData)[];\r\n  validationMessages: Record<string, string>;\r\n}\r\n\r\nexport const FORM_SECTIONS: FormSection[] = [\r\n  {\r\n    id: 'identification',\r\n    title: \"Identification de l'instrument\",\r\n    description: \"Informations de base\",\r\n    fields: ['symbol', 'description', 'isin', 'expirationCode', 'parentTicker', 'fullName', 'segment', 'maturityDate'],\r\n    requiredFields: ['symbol', 'isin', 'fullName'],\r\n    validationMessages: {\r\n      symbol: 'Le symbole est requis pour identifier l\\'instrument',\r\n      isin: 'Le code ISIN est obligatoire',\r\n      fullName: 'Le nom complet de l\\'instrument est requis'\r\n    }\r\n  },\r\n  {\r\n    id: 'deposit',\r\n    title: \"Dépôt & sous-jacents\",\r\n    description: \"Configuration des marges\",\r\n    fields: ['depositType', 'lotSize', 'initialMarginAmount', 'percentageMargin', 'underlyingType', 'underlyingId'],\r\n    requiredFields: ['depositType', 'lotSize', 'underlyingType', 'underlyingId'],\r\n    validationMessages: {\r\n      depositType: 'Veuillez sélectionner le type de dépôt',\r\n      lotSize: 'La taille de lot doit être supérieure à 0',\r\n      underlyingType: 'Veuillez sélectionner le type de sous-jacent',\r\n      underlyingId: 'Veuillez sélectionner un sous-jacent'\r\n    }\r\n  },\r\n  {\r\n    id: 'trading',\r\n    title: \"Négociation\",\r\n    description: \"Paramètres de trading\",\r\n    fields: ['firstTradingDate', 'lastTraadingDate', 'tradingCurrency', 'tickSize', 'settlementMethod', 'instrumentStatus'],\r\n    requiredFields: ['firstTradingDate', 'lastTraadingDate', 'tradingCurrency', 'tickSize', 'settlementMethod'],\r\n    validationMessages: {\r\n      firstTradingDate: 'La date de première négociation est requise',\r\n      lastTraadingDate: 'La date de dernière négociation est requise',\r\n      tradingCurrency: 'La devise de négociation est obligatoire',\r\n      tickSize: 'Le tick size doit être supérieur à 0',\r\n      settlementMethod: 'Veuillez sélectionner la méthode de règlement'\r\n    }\r\n  }\r\n];\r\n\r\nexport interface StepValidationResult {\r\n  isValid: boolean;\r\n  missingFields: string[];\r\n  errorMessages: string[];\r\n  canProceed: boolean;\r\n}\r\n\r\nexport const useFormNavigation = (form: FutureFormData, errors: Record<string, string>) => {\r\n  const [currentStep, setCurrentStep] = useState(0);\r\n  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());\r\n  const [justArrivedOnLastStep, setJustArrivedOnLastStep] = useState(false);\r\n\r\n  // Check if a step is completed\r\n  const isStepCompleted = useCallback((stepIndex: number): boolean => {\r\n    const section = FORM_SECTIONS[stepIndex];\r\n    if (!section) return false;\r\n\r\n    return section.requiredFields.every(field => {\r\n      const value = form[field];\r\n      if (typeof value === 'string') {\r\n        return value.trim() !== '';\r\n      }\r\n      if (typeof value === 'number') {\r\n        return value > 0;\r\n      }\r\n      if (typeof value === 'boolean') {\r\n        return true; // Boolean fields are always considered valid\r\n      }\r\n      return value !== undefined && value !== null;\r\n    });\r\n  }, [form]);\r\n\r\n  // Validate current step with detailed feedback\r\n  const validateCurrentStep = useCallback((): StepValidationResult => {\r\n    const section = FORM_SECTIONS[currentStep];\r\n    if (!section) {\r\n      return {\r\n        isValid: false,\r\n        missingFields: [],\r\n        errorMessages: ['Section invalide'],\r\n        canProceed: false\r\n      };\r\n    }\r\n\r\n    const missingFields: string[] = [];\r\n    const errorMessages: string[] = [];\r\n\r\n    // Check required fields\r\n    section.requiredFields.forEach(field => {\r\n      const value = form[field];\r\n      let isValid = true;\r\n\r\n      if (typeof value === 'string') {\r\n        isValid = value.trim() !== '';\r\n      } else if (typeof value === 'number') {\r\n        isValid = value > 0;\r\n      } else if (typeof value === 'boolean') {\r\n        isValid = true;\r\n      } else {\r\n        isValid = value !== undefined && value !== null;\r\n      }\r\n\r\n      if (!isValid) {\r\n        missingFields.push(field as string);\r\n        errorMessages.push(section.validationMessages[field as string] || `Le champ ${field} est requis`);\r\n      }\r\n    });\r\n\r\n    // Check for validation errors\r\n    section.fields.forEach(field => {\r\n      if (errors[field as string]) {\r\n        errorMessages.push(errors[field as string]);\r\n      }\r\n    });\r\n\r\n    const isValid = missingFields.length === 0 && errorMessages.length === 0;\r\n    const canProceed = isValid;\r\n\r\n    return {\r\n      isValid,\r\n      missingFields,\r\n      errorMessages,\r\n      canProceed\r\n    };\r\n  }, [currentStep, form, errors]);\r\n\r\n  // Check if current step has errors\r\n  const hasStepErrors = useCallback((): boolean => {\r\n    const section = FORM_SECTIONS[currentStep];\r\n    if (!section) return false;\r\n\r\n    return section.fields.some(field => errors[field as string]);\r\n  }, [currentStep, errors]);\r\n\r\n  // Get validation summary for current step\r\n  const getCurrentStepValidation = useCallback((): StepValidationResult => {\r\n    return validateCurrentStep();\r\n  }, [validateCurrentStep]);\r\n\r\n  // Get validation summary for specific step\r\n  const getStepValidation = useCallback((stepIndex: number): StepValidationResult => {\r\n    const section = FORM_SECTIONS[stepIndex];\r\n    if (!section) {\r\n      return {\r\n        isValid: false,\r\n        missingFields: [],\r\n        errorMessages: ['Section invalide'],\r\n        canProceed: false\r\n      };\r\n    }\r\n\r\n    const missingFields: string[] = [];\r\n    const errorMessages: string[] = [];\r\n\r\n    section.requiredFields.forEach(field => {\r\n      const value = form[field];\r\n      let isValid = true;\r\n\r\n      if (typeof value === 'string') {\r\n        isValid = value.trim() !== '';\r\n      } else if (typeof value === 'number') {\r\n        isValid = value > 0;\r\n      } else if (typeof value === 'boolean') {\r\n        isValid = true;\r\n      } else {\r\n        isValid = value !== undefined && value !== null;\r\n      }\r\n\r\n      if (!isValid) {\r\n        missingFields.push(field as string);\r\n        errorMessages.push(section.validationMessages[field as string] || `Le champ ${field} est requis`);\r\n      }\r\n    });\r\n\r\n    const isValid = missingFields.length === 0;\r\n    const canProceed = isValid;\r\n\r\n    return {\r\n      isValid,\r\n      missingFields,\r\n      errorMessages,\r\n      canProceed\r\n    };\r\n  }, [form]);\r\n\r\n  // Go to next step\r\n  const nextStep = useCallback((): boolean => {\r\n    if (currentStep >= FORM_SECTIONS.length - 1) {\r\n      return false; // Already on last step\r\n    }\r\n\r\n    const validation = validateCurrentStep();\r\n    if (!validation.canProceed) {\r\n      return false; // Current step is not valid\r\n    }\r\n\r\n    // Mark current step as completed\r\n    setCompletedSteps(prev => new Set(prev).add(currentStep));\r\n    \r\n    // Move to next step\r\n    const nextStepIndex = currentStep + 1;\r\n    setCurrentStep(nextStepIndex);\r\n\r\n    // Check if we just arrived on the last step\r\n    if (nextStepIndex === FORM_SECTIONS.length - 1) {\r\n      setJustArrivedOnLastStep(true);\r\n    }\r\n\r\n    return true;\r\n  }, [currentStep, validateCurrentStep]);\r\n\r\n  // Go to previous step\r\n  const prevStep = useCallback((): boolean => {\r\n    if (currentStep <= 0) {\r\n      return false; // Already on first step\r\n    }\r\n\r\n    setCurrentStep(prev => prev - 1);\r\n    setJustArrivedOnLastStep(false);\r\n    return true;\r\n  }, [currentStep]);\r\n\r\n  // Go to specific step\r\n  const goToStep = useCallback((stepIndex: number): boolean => {\r\n    if (stepIndex < 0 || stepIndex >= FORM_SECTIONS.length) {\r\n      return false; // Invalid step index\r\n    }\r\n\r\n    // Only allow going to completed steps or the next available step\r\n    if (stepIndex > currentStep && !completedSteps.has(stepIndex - 1)) {\r\n      return false; // Cannot skip steps\r\n    }\r\n\r\n    setCurrentStep(stepIndex);\r\n    setJustArrivedOnLastStep(stepIndex === FORM_SECTIONS.length - 1);\r\n    return true;\r\n  }, [currentStep, completedSteps]);\r\n\r\n  // Check if form is ready for submission\r\n  const isFormReadyForSubmission = useCallback((): boolean => {\r\n    // Must be on last step\r\n    if (currentStep !== FORM_SECTIONS.length - 1) {\r\n      return false;\r\n    }\r\n\r\n    // All steps must be completed\r\n    if (completedSteps.size < FORM_SECTIONS.length - 1) {\r\n      return false;\r\n    }\r\n\r\n    // Current step must be valid\r\n    return validateCurrentStep().canProceed;\r\n  }, [currentStep, completedSteps, validateCurrentStep]);\r\n\r\n  // Get current section\r\n  const getCurrentSection = useCallback((): FormSection | undefined => {\r\n    return FORM_SECTIONS[currentStep];\r\n  }, [currentStep]);\r\n\r\n  // Get section by index\r\n  const getSection = useCallback((index: number): FormSection | undefined => {\r\n    return FORM_SECTIONS[index];\r\n  }, []);\r\n\r\n\r\n\r\n  return {\r\n    // State\r\n    currentStep,\r\n    completedSteps,\r\n    justArrivedOnLastStep,\r\n    \r\n    // Actions\r\n    nextStep,\r\n    prevStep,\r\n    goToStep,\r\n    \r\n    // Computed values\r\n    isStepCompleted,\r\n    validateCurrentStep,\r\n    hasStepErrors,\r\n    isFormReadyForSubmission,\r\n    getCurrentSection,\r\n    getSection,\r\n    getCurrentStepValidation,\r\n    getStepValidation,\r\n    \r\n    // Constants\r\n    totalSteps: FORM_SECTIONS.length,\r\n    sections: FORM_SECTIONS,\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}